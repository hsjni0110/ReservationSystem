# 멀티 모듈 기반 구조 도입

## 현재 도메인 패키지 구조

<br />

현재 도메인 패키지 구조는 다음과 같습니다.

<br />

- account: 계좌 차감, 충전, 조회 등의 로직을 담당합니다.
- auth: 인증/인가를 담당합니다.
- common: 공통 로직 처리, 이벤트 아웃박스 서비스, 퍼블리셔 구현체(카프카), 스케줄러, 타입, 유틸 등을 담당합니다.
- payment: 결제 관련 처리를 담당합니다.
- reservation: 예약 처리, 예약 조회 등을 담당합니다.
- user
    - point: 유저 포인트 적립, 차감 처리를 담당합니다.
    - signin: 로그인을 담당합니다.
    - signup: 회원가입을 담당합니다.
- vehicle: 버스 및 경로 생성 로직을 담당합니다.

<br />

현재 구조는 EDA를 도입하여 Kafka를 사용하여 payment 시, event 기반으로 reservation, account, point에서 처리가 이루어지는 구조입니다.

<br />

## 문제점

<br />

다음과 같은 문제점이 있습니다.

<br />

- common에서 유스케이스 제거가 필요하며, 비즈니스 로직은 도메인 모듈에만 존재해야 합니다.
- 모든 Config 설정들이 common에 위치하여 해당 설정에 대한 영향이 모든 모듈로 확산될 수 있습니다.

<br />

따라서 시스템 종속적인 모듈 분리가 필요합니다.

<br />

---

<br />

# 멀티 모듈 적용 과정

## 단일 모듈 → 멀티 모듈 구조로의 변경

<br />

가장 먼저, `setting.gradle`에 아래 설정을 적용합니다.

<br />

```gradle
rootProject.name = 'ReservationSystem'  
  
include(  
        "core-api"  
)  
  
project(':core-api').projectDir = file('core/core-api')
```

<br />

이후 Gradle 새로고침을 적용하면, 모듈로써 core 디렉토리 하위에 core-api가 생성됩니다.
이 core-api는 runnable한 유일한 모듈로 작동할 것입니다.

<br />

그리고 앞으로 생겨날 각 모듈에 대해서 전체 모듈에 적용시켜줄 의존성과 각 서브 모듈에 적용시켜줄 의존성을 분리해야 합니다. 지금의 경우는 막 분리를 시작했으므로 모든 의존성 자체를 서브 모듈 아래에 두었습니다.

<br />

![Image](https://github.com/user-attachments/assets/658dd40e-aa45-47f2-82b9-662208bad669)

<br />

subprojects 하위에 기존 단일 모듈에서 적용되고 있던 모든 의존성을 붙여넣어 주었습니다.

<br />

이후 테스트로 실행 결과가 잘 되는 것을 확인할 수 있습니다.
이제 가장 먼저 분리해 볼 것은 현재 결합되어 있는 도메인과 데이터베이스와 관련된 종속성을 분리하고자 했습니다.

<br />

## db-core에 대한 분리 시도

<br />

도메인 모듈에는 비즈니스 로직과 도메인 로직, 도메인 객체가 들어가도록 해야 합니다.

하지만, 현재 로직에는 이러한 도메인 로직을 수행하는 도메인 객체가 실제 JPA 기술과 결합된 형태입니다. 다시 말해, @Entity가 붙은 클래스에서 도메인 로직을 수행하고 있습니다.

따라서, 이를 분리해야 할 필요가 있다고 판단했습니다.
하지만, 실제로 Bus와 관련된 종속성을 분리한 결과는 다음과 같습니다.

<br />

![Image](https://github.com/user-attachments/assets/af39b68a-8f04-42e5-ae55-0e7a9ac1e795)

<br />

분리의 결과 아래와 같은 단점을 고려해볼 수 있었습니다.

<br />

1. 상당수의 부가적인 클래스가 생성됩니다.
   가령 Bus 도메인과 Bus 엔티티를 분리한다고 할 때, Bus와 BusEntity를 만들어야 하고 이를 분리할 수도 있어야 합니다.
   또한 레포지토리도 한 단계 추상화시켜야 하므로 이에 따른 인터페이스와 구현체도 추가적으로 생깁니다.

<br />

2. JPA의 영속화와 관련된 이점을 얻을 수가 없습니다.
   db-core가 따로 분리됨으로 인해, Dirty-Checking과 같은 이점을 얻을 수가 없으므로 굳이 JPA를 쓰는 이점 자체가 사라집니다.

<br />

특히나 JPA를 제외한 다른 인터페이스를 사용하여 데이터베이스를 핸들링할 여지가 있는가? 그것도 아니었습니다.
즉, 현재 상황에 있어서 db-core를 분리할 필요는 크게 없어 보였습니다.

<br />

## api에 대한 분리 시도

<br />

주요 도메인 로직은 도메인 모듈에 담당하고 사용자로부터 앞단의 요청을 받는 부분을 따로 분리해 주었습니다. 이를 통해서 API 모듈은 HTTP 프로토콜과 요청/응답에만 신경 쓰면 됩니다.

api에 대한 분리의 이유는 크게 아래와 같습니다.

<br />

1. 관심사의 분리
   API 모듈은 실제로 실행 가능한 모듈로써, 비즈니스 로직과는 분리되어 처리할 수 있습니다.

<br />

2. 다양한 프로토콜을 필요로 할 수 있습니다.
   버스 예약 시스템에서 좌석 정보와 가격만을 빠르게 알고 싶다는 요구사항과 같이 다계층이 연결된 쿼리에서 유연한 조회를 위해 GraphQL 등을 사용할 수 있습니다.
   또한 마이크로서비스 구조로 추후 확장될 경우 좌석, 결제, 스케줄 관리 서비스 호출 간에 지연을 줄이기 위해 gRPC 등을 사용할 수도 있습니다.

<br />

3. 버전 관리가 편해집니다.
   API 엔드 포인트에 대한 지점은 특정 버전으로 업데이트될 때마다 바뀔 수 있습니다.
   특정 버전마다 API 엔드 포인트에 대한 지점관리가 편해지므로 분리의 장점이 됩니다.

<br />

위와 같은 이유로 API 에 대해서는 별도로 분리를 수행했습니다.

<br />

![Image](https://github.com/user-attachments/assets/70e51eb7-9c55-450f-a2de-4086e19fb308)

<br />

## 도메인 모듈 분리

<br />

MSA 구조로 확장될 가능성을 고려하여 해당 멀티 모듈의 구조도 도메인 별 모듈로 따로 분리했습니다.
이때, 기존에 도메인 별로 분리해두었던 패키지 별 의존성을 미리 체크했습니다.

<br />

![Image](https://github.com/user-attachments/assets/b6802275-b4d0-4253-8b3e-ef9dce255ac4)

<br />

그 과정에서 의존성 사이클이 발생하는 부분은 이벤트 기반 처리를 하거나 중간 객체를 두어 느슨하게 처리해 주었습니다. 현재 구조에 있어서는 point를 직접 결제 시 적용하는 기능 자체는 구현하지 않았기에 point에는 의존성이 발생하지 않았습니다.
위와 같이 의존성을 파악하고, 아래와 같이 도메인 모듈을 분리했습니다.

<br />

- account
- payment
- reservation
    - reservation
    - vehicle
- user
    - point
    - user

<br />

도메인 모듈 분리는 https://www.youtube.com/watch?v=dJ5C4qRqAgA 를 참고하여 이를 기준으로 분리했습니다.

<br />

point와 user의 경우에는 현재의 요구사항에 한정하여 “동일한 라이프사이클” 을 공유하기 때문에 동일 모듈 상에 두었습니다.

<br />

reservation의 경우에는 현재 vehicle의 제약사항(배차 여부)에 따라 상태가 변하는 경우가 빈번하기 때문에 동일한 모듈 상에 두었습니다.

<br />

## 이벤트 아웃박스 모듈 분리

<br />

이벤트 아웃박스 패턴을 사용하는 모듈은 payment, reservation, point, account 모듈입니다. 이와 관련되지 않은 다른 모듈은 필요도 하지 않은 Kafka 의존성을 가지고 있을 필요가 없습니다.

또한 하나의 도메인 모듈이 너무 많은 인프라를 의존하는 경우를 최소화하고 싶었기 때문에 이벤트 아웃박스에 대한 로직을 담당하는 모듈로 분리할 필요가 있었습니다.

분리 결과는 아래와 같습니다.

<br />

![Image](https://github.com/user-attachments/assets/99448635-e214-4cd2-8a1d-cd205b9bde66)

<br />

## 실행 지점 바꾸기

<br />

어플리케이션 실행 지점은 현재 core-api 모듈 측 뿐입니다. 하지만, 실행 시 scan base가 api 모듈 바깥쪽까지 스캔해야하기 때문에 모든 모듈을 작성해주어야 하는 귀찮음이 있습니다.

이에 대해서 찾아본 결과, https://techblog.woowahan.com/2637/ 를 보고 어플리케이션 실행 지점을 상위 패키지로 올려 줄 수 있었고, 이에 따라 여러 scan base를 작성하지 않고도 어플리케이션을 실행할 수 있었습니다.

<br />

## 개선점

<br />

분리를 수행하며 common 모듈에 들어가는 의존성이 어쩔 수 없이 늘어나는 경우가 있었습니다. 특히 인증, 인가와 관련된 어노테이션 및 기능들을 common에 넣어두었는데 이는 아직까지 인증과 인가에 관련된 부분이 그렇게 까지 크지 않기 때문이었습니다. 그렇다 치더라도 현재 굳이 common에 두지 않아도 되는 기능들이 몇 있기 때문에 이 부분은 개선해야 할 점이라 생각합니다.
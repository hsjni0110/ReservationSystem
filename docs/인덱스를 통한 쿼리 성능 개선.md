# 버스 예약 시스템에서의 인덱스 적용

## 인덱스가 필요해 보이는 쿼리

### 예약 가능 경로 조회

#### 인덱스 적용 근거

```sql
select
    r1_0.route_id,
    r1_0.arrival,
    r1_0.departure,
    r1_0.schedule_date
from
    route r1_0
where
    r1_0.departure='대전복합터미널'
  and r1_0.arrival='서울고속버스터미널'
  and r1_0.schedule_date='2025-03-29';
```

예약 가능한 경로를 조회하는 기능에서 인덱스를 통해 실행 계획을 최적화해야 한다고 판단했습니다. 그 이유는 다음과 같습니다.

1. 자주 조회되는 요청입니다.

버스예약시스템에 있어 핵심적인 로직은 예약 가능한 시간대의 경로가 있는지 찾는 것입니다. 설령 예약을 하지 않더라도,
어느 시간대에 어떤 버스를 타고 어디에서 어디로 가는지에 대한 정보는 최적화할 필요가 있습니다.

2. 카디널리티가 높습니다.

카디널리티가 높다는 것의 의미는 중복도가 낮다는 것과 같습니다. 사실, `departure`, `arrival`을 따로 두고 본다면
 중복된 값들은 당연히 존재합니다. 버스 터미널의 개수는 어느정도 정해져있으니까요. 하지만, 우리가 버스 예약을 하려고 할 때,
 당일로만 조회하지 않습니다. 대략 한달정도는 간격을 두고 계획을 짜기 때문에 이에 대한 경로는 유니크해집니다.

즉, 핵심은 해당 쿼리에서도 나타나듯이 세 칼럼에 대한 조합으로 인덱스를 구성한다면 그에 대한 카디널리티는 높습니다.

3. DML 작업이 자주 일어나는가?

DML 작업이 일어나면, 인덱스에서는 그 구조를 유지하기 위해 어느정도 오버헤드를 감수해야 합니다.
버스 예약 시스템에서 예약 가능한 경로를 탐색하는 것은 그리 많지 않습니다. 만약 한 달 간격으로 경로가 생성되고, 삭제되는 비즈니스라면
 한 달마다 연산이 일어날 뿐, 중간에 DML 연산이 일어나는 경우는 드뭅니다.

4. 읽어야 하는 레코드 건수가 많은가?

인덱스를 통해서 데이터를 읽어오는 작업은 필터링 대상 데이터 전체의 20에서 25%를 넘어서는 안됩니다.
그 이유는 인덱스를 통해서 값을 읽는다면 테이블에서 직접 읽는 것에 비해 4에서 5배 정도 비용이 크기 때문입니다.(Random I/O 때문인듯 합니다.)

현재 조회하는 쿼리는 동일한지에 대한 비교밖에 없어 이는 크게 신경쓰지 않아도 될 듯 하네요.

#### 인덱스 적용 방법

- 인덱스 적용 이전

<img width="874" alt="image" src="https://github.com/user-attachments/assets/4820bd53-d0a3-461e-9fe6-08c255322af7">

<img width="874" alt="image" src="https://github.com/user-attachments/assets/4820bd53-d0a3-461e-9fe6-08c255322af7">

인덱스를 적용하기 위한 SQL 구문은 다음과 같습니다. 현재는 484 밀리세컨만큼의 시간이 소요됩니다.

<img width="557" alt="image" src="https://github.com/user-attachments/assets/f0f84181-8a1a-42b7-a985-cb88c4413a1b">

혹은 아래와 같이 jakarta.persistence에서 제공하는 `@Table` 어노테이션에 `Index` 속성을 부여하면 됩니다.

<img width="972" alt="Image" src="https://github.com/user-attachments/assets/f45144df-c634-4bf9-be35-e0ec45b5a8b6">

이때 주의해야 할 점은 인덱스를 걸어줄 컬럼의 순서를 적용시키려는 쿼리를 고려해서 설정해야 합니다.
그 이유는 인덱스 구조에서는 후행 칼럼이 선행 칼럼의 영향을 받아 정렬되기 때문입니다.

그래서 신경쓰지 않고 넣어준다면, 인덱스가 적용되지 않을 가능성이 있습니다. 물론 MySQL 8.0 버전 이상부터는 인덱스 스킨 스캔 옵션을 켜서 적용 대상이 아닌 칼럼을
 건너뛸 수도 있습니다.

#### 인덱스 적용 이후

인덱스를 적용시켜준 이후에 동일한 쿼리를 날려보겠습니다.

<img width="796" alt="Image" src="https://github.com/user-attachments/assets/1cd8c482-8e10-4530-a521-7ec576178b19" />

속도가 **182 밀리세컨으로 기존의 484 밀리세컨**에 비해서 월등히 좋아진 것을 볼 수 있습니다.

<img width="810" alt="Image" src="https://github.com/user-attachments/assets/e7e30241-9ae7-4186-b84c-275266501e07" />

explain을 통해서 옵티마이저가 무엇을 사용했는지 살펴봅시다. key는 설정한 인덱스로 잘 들어갔으며 상수 비교를 진행했음을 ref에서 나타냅니다.
읽은 행의 횟수도 1로 매우 효과적입니다. 특히 `Using Index`만 적혀있는 것은 커버링 인덱스를 사용했다는 것입니다. 이는 인덱스를 적용한 칼럼만을 select했기 때문에 굳이 클러스터링 인덱스를 탐색할 필요가 없기 때문입니다.

그런데 이상한 점이 있습니다. `key_len`이 생각 외로 너무 큽니다. `key_len`이 너무 커버리게 되면 아래와 같은 단점이 있습니다.

1. 하나의 인덱스 페이지에 저장해야 하는 키의 갯수가 줄어듭니다.
2. 인덱스를 캐시해두는 InnoDB의 버퍼 풀도 한정적이기 때문에 메모리 효율적이지 못합니다.
3. B-Tree의 깊이가 깊어져 디스크 읽기를 더 해야한다.

한마디로 `key_len`이 너무 커버리면 인덱스의 효율이 저하됩니다. 보통은 인덱스 키가 16바이트일때, 한 페이지 당 585개의 블럭을 저장할 수 있으나
 지금의 경우에는 너무 비효율적이겠네요.

> 하지만 지금은 읽은 행의 횟수가 1이기 때문에 사실 차이는 없다고 예상됩니다.

#### key_len 감소 이후

저는 아래와 같이 `@Column(length = 50)`을 통해서 그 길이를 줄여주었습니다. 물론, 직접 SQL로 바꾸어줄 수도 있습니다.

```sql
@Entity
public class Route {

    @Column(length = 50)
    private String departure;

    @Column(length = 50)
    private String arrival;
...
```

해당 설정으로 바꾸어준 뒤 다시 한번 실행 시켜줍시다.

<img width="815" alt="Image" src="https://github.com/user-attachments/assets/3cc78c3d-5b65-4e65-9a14-9299a5553da5" />

key_len을 410으로 줄였습니다. 다만, 역시나 성능 자체는 큰 차이가 없습니다.

<img width="862" alt="Image" src="https://github.com/user-attachments/assets/defc12d5-02e3-44e9-a0e8-96a6b7b86b77" />
